<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Update Title/Description for Multiplayer -->
  <title>14-High! (Multiplayer)</title>
  <meta name="description" content="Real-time multiplayer scoring app for the 14-High! card game. Play with friends on any device.">
  <meta name="theme-color" content="#4f46e5">
  <link rel="manifest" href="manifest.json"> <!-- Consider updating manifest for new title -->
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Modern CSS Reset and Base Styles */
    :root {
      --primary: #4f46e5; /* Indigo */
      --primary-hover: #4338ca;
      --secondary: #14b8a6; /* Teal */
      --success: #22c55e; /* Green */
      --success-hover: #16a34a;
      --danger: #ef4444; /* Red */
      --danger-hover: #dc2626;
      --warning: #f59e0b; /* Amber */
      --light: #ffffff;
      --light-alt: #f9fafb; /* Very light gray */
      --dark: #111827; /* Dark gray */
      --dark-alt: #1f2937; /* Slightly lighter dark gray */
      --gray: #6b7280; /* Medium gray */
      --gray-light: #e5e7eb; /* Light gray */
      --gray-dark: #374151; /* Darker gray */
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --radius: 0.375rem; /* 6px */
      --transition: all 0.2s ease-in-out;
      --font-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    /* Dark mode variables */
    [data-theme="dark"] {
      --primary: #6366f1; /* Lighter Indigo */
      --primary-hover: #818cf8;
      --secondary: #2dd4bf; /* Lighter Teal */
      --success: #4ade80; /* Lighter Green */
      --success-hover: #86efac;
      --danger: #f87171; /* Lighter Red */
      --danger-hover: #fda4af;
      --warning: #fbbf24; /* Lighter Amber */
      --light: #121212; /* Dark background */
      --light-alt: #1e1e1e; /* Slightly lighter dark background */
      --dark: #f8fafc; /* Light text */
      --dark-alt: #e2e8f0; /* Slightly darker light text */
      --gray: #94a3b8; /* Lighter gray */
      --gray-light: #2c2c2c; /* Darker borders/dividers */
      --gray-dark: #3a3a3a; /* Even darker elements */
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.4), 0 1px 2px -1px rgb(0 0 0 / 0.4);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.4);
    }

    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      background-color: var(--light-alt);
      color: var(--dark);
      font-family: var(--font-sans);
      line-height: 1.6;
      padding: 1.5rem;
      min-height: 100vh;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .container {
      max-width: 700px; /* Slightly narrower for a sleeker feel */
      margin: 0 auto;
    }

    #app {
      margin-top: 4rem; /* Space for fixed header */
    }

    /* Typography */
    h1, h2, h3, h4 {
      font-weight: 600;
      line-height: 1.3;
      margin-bottom: 1rem;
      color: var(--dark);
    }

    h1 {
      font-size: 2.25rem; /* Slightly larger */
      font-weight: 700;
      text-align: center;
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      z-index: 900;
      /* Simpler, more subtle gradient */
      background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      /* Fallback for browsers that don't support background-clip: text */
      color: var(--primary);
      width: auto; /* Allow title to properly size itself */
    }

    /* Create a fixed header area for all fixed elements */
    .fixed-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 4rem; /* Match the margin-top for #app */
      background-color: var(--light-alt);
      z-index: 800;
      box-shadow: var(--shadow);
      transition: background-color 0.3s ease;
    }

    [data-theme="dark"] .fixed-header {
      background-color: var(--light-alt);
    }

    h2 {
      font-size: 1.25rem;
      margin-bottom: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--dark);
    }

    h3 {
      font-size: 1rem;
      margin-bottom: 0.75rem;
      font-weight: 500;
      color: var(--gray);
    }

    /* Card styles */
    .card {
      background-color: var(--light);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 1.25rem 1.5rem;
      margin-bottom: 1.5rem;
      border: 1px solid var(--gray-light);
      transition: var(--transition);
    }

    [data-theme="dark"] .card {
      background-color: var(--light-alt);
      border-color: var(--gray-dark);
    }

    /* Form elements */
    .input-group {
      display: flex;
      margin-bottom: 1rem;
      position: relative;
    }

    input, button {
      font-size: 0.9375rem; /* Slightly smaller */
      font-family: inherit;
      transition: var(--transition);
    }

    input[type="text"],
    input[type="number"] {
      flex-grow: 1;
      padding: 0.625rem 0.875rem; /* Adjusted padding */
      border: 1px solid var(--gray-light);
      border-radius: var(--radius);
      background-color: var(--light);
      color: var(--dark);
      outline: none;
      box-shadow: var(--shadow-sm);
    }

    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="number"] {
      background-color: var(--gray-dark);
      border-color: var(--gray-dark);
      color: var(--dark);
    }

    input[type="text"]:focus,
    input[type="number"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); /* Adjusted focus ring */
    }

    [data-theme="dark"] input[type="text"]:focus,
    [data-theme="dark"] input[type="number"]:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4); /* Dark mode focus ring */
    }

    input[type="number"] {
      width: 4.5rem; /* Slightly narrower */
      text-align: center;
      -moz-appearance: textfield; /* Hide spinners in Firefox */
    }
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none; /* Hide spinners in Chrome, Safari, Edge */
      margin: 0;
    }

    .input-with-button {
      display: flex;
      width: 100%;
    }

    .input-with-button input {
      border-radius: var(--radius) 0 0 var(--radius);
      border-right: none;
    }

    button {
      padding: 0.625rem 1rem; /* Adjusted padding */
      border: none;
      border-radius: var(--radius);
      background-color: var(--primary);
      color: white;
      cursor: pointer;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.375rem; /* Gap between icon and text */
      transition: var(--transition);
      white-space: nowrap;
    }

    button:hover:not(:disabled) {
      background-color: var(--primary-hover);
      transform: translateY(-1px); /* Subtle lift */
      box-shadow: var(--shadow-sm);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    button:disabled {
      background-color: var(--gray-light);
      color: var(--gray);
      cursor: not-allowed;
      opacity: 0.7;
    }

    [data-theme="dark"] button:disabled {
        background-color: var(--gray-dark);
        color: var(--gray);
    }

    .btn-add {
      border-radius: 0 var(--radius) var(--radius) 0;
    }

    .btn-full {
      display: block;
      width: 100%;
      margin-top: 0.75rem;
      padding: 0.75rem;
    }

    .btn-green {
      background-color: var(--success);
    }

    .btn-green:hover:not(:disabled) {
      background-color: var(--success-hover);
    }

    .btn-red {
      background-color: var(--danger);
    }

    .btn-red:hover:not(:disabled) {
      background-color: var(--danger-hover);
    }

    .btn-outline {
      background-color: transparent;
      border: 1px solid var(--gray-light);
      color: var(--primary);
    }

    .btn-outline:hover:not(:disabled) {
      background-color: rgba(79, 70, 229, 0.05); /* Light primary background */
      border-color: var(--primary);
    }

    [data-theme="dark"] .btn-outline {
      border-color: var(--gray-dark);
      color: var(--primary);
    }

    [data-theme="dark"] .btn-outline:hover:not(:disabled) {
      background-color: rgba(99, 102, 241, 0.1);
      border-color: var(--primary);
    }

    /* Player list */
    .player-list {
      margin: 0.75rem 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .player-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--light-alt);
      padding: 0.625rem 1rem;
      border-radius: var(--radius);
      border: 1px solid var(--gray-light);
      transition: var(--transition);
    }

    .player-item span {
      font-weight: 500;
    }

    [data-theme="dark"] .player-item {
      background-color: var(--light);
      border-color: var(--gray-dark);
    }

    .btn-remove {
      background: none;
      color: var(--danger);
      padding: 0.25rem; /* Smaller padding for icon button */
      border-radius: 50%; /* Circular */
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-remove:hover {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger-hover);
      transform: none; /* No translate on hover for remove */
      box-shadow: none;
    }

    /* Tables */
    .table-container {
      overflow-x: auto;
      margin-bottom: 1.5rem;
      border-radius: var(--radius);
      border: 1px solid var(--gray-light);
      background-color: var(--light); /* Ensure background for container */
    }

    [data-theme="dark"] .table-container {
      border-color: var(--gray-dark);
    }

    table {
      width: 100%;
      border-collapse: collapse; /* Use collapse for cleaner lines */
      font-size: 0.9rem;
    }

    [data-theme="dark"] table {
      background-color: var(--light-alt);
    }

    th {
      text-align: left;
      padding: 0.75rem 1rem;
      background-color: var(--light-alt);
      font-weight: 500; /* Lighter weight */
      color: var(--gray);
      text-transform: uppercase; /* Uppercase headers */
      letter-spacing: 0.05em;
      font-size: 0.75rem; /* Smaller header text */
      border-bottom: 1px solid var(--gray-light);
    }

    td {
      padding: 0.875rem 1rem; /* Increased padding for rows */
      border-bottom: 1px solid var(--gray-light);
      vertical-align: middle;
      color: var(--dark);
    }

    tbody tr:last-child td {
      border-bottom: none; /* Remove border from last row */
    }

    /* Remove alternating row colors for minimalism */
    /* tr:nth-child(even) { background-color: var(--light-alt); } */

    tbody tr:hover {
      background-color: rgba(79, 70, 229, 0.03); /* Very subtle hover */
    }

    [data-theme="dark"] th {
      background-color: var(--light);
      border-bottom-color: var(--gray-dark);
      color: var(--gray);
    }

    [data-theme="dark"] td {
      border-bottom-color: var(--gray-dark);
      color: var(--dark-alt);
    }

    [data-theme="dark"] tbody tr:last-child td {
        border-bottom: none;
    }

    [data-theme="dark"] tbody tr:hover {
      background-color: rgba(99, 102, 241, 0.05);
    }

    td:last-child {
      font-weight: 600;
    }

    .winner-row {
      background-color: rgba(34, 197, 94, 0.05) !important;
      border-left: 3px solid var(--success);
      position: relative;
    }
    .winner-row td:first-child {
      padding-left: calc(1rem - 3px); /* Adjust padding because of border */
    }

    [data-theme="dark"] .winner-row {
      background-color: rgba(74, 222, 128, 0.08) !important;
    }

    /* Winner display */
    .winner-display {
      margin-bottom: 2rem;
      text-align: center;
      background-color: var(--light-alt); /* Subtle background */
      padding: 1.5rem;
      border-radius: var(--radius);
      border: 1px solid var(--gray-light);
    }

    [data-theme="dark"] .winner-display {
        background-color: var(--dark-alt);
        border-color: var(--gray-dark);
    }

    .winner-display h3 {
        color: var(--gray);
        margin-bottom: 0.5rem;
    }

    .winner-name {
      font-size: 1.5rem; /* Slightly smaller */
      font-weight: 600;
      color: var(--success);
      margin-top: 0.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .winner-name .fa-crown {
        color: var(--warning);
    }

    /* Layout utilities */
    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .game-status {
      display: inline-block;
      font-size: 0.8rem;
      font-weight: 500;
      padding: 0.25rem 0.625rem;
      border-radius: 100px;
      background-color: rgba(79, 70, 229, 0.1); /* Primary subtle bg */
      color: var(--primary);
      margin-bottom: 0.5rem; /* Reduced from 1rem */
    }

    [data-theme="dark"] .game-status {
        background-color: rgba(99, 102, 241, 0.15);
        color: var(--primary);
    }

    .badge {
      display: inline-block;
      padding: 0.25rem 0.625rem;
      border-radius: var(--radius);
      font-size: 0.8rem;
      font-weight: 500;
      margin-left: 0.5rem;
    }

    .badge-blue {
      background-color: rgba(79, 70, 229, 0.1);
      color: var(--primary);
    }

    .badge-green {
      background-color: rgba(34, 197, 94, 0.1);
      color: var(--success);
    }

    [data-theme="dark"] .badge-blue {
        background-color: rgba(99, 102, 241, 0.2);
    }
    [data-theme="dark"] .badge-green {
        background-color: rgba(74, 222, 128, 0.2);
    }

    .trick-value {
      display: flex;
      align-items: center;
      justify-content: flex-start; /* Align input left in cell */
    }

    .score-value {
      font-weight: 600;
      color: var(--primary);
    }

    /* Hamburger menu styles */
    .hamburger-menu {
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 1000;
    }

    .hamburger-btn, .menu-close {
      background: var(--light);
      border: 1px solid var(--gray-light);
      color: var(--gray);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border-radius: 50%; /* Circular */
      transition: var(--transition);
      padding: 0;
      font-size: 1rem; /* Adjust icon size */
      box-shadow: var(--shadow);
    }
    .hamburger-btn:hover, .menu-close:hover {
        background: var(--light-alt);
        color: var(--primary);
        transform: scale(1.05); /* Slight scale on hover */
        box-shadow: var(--shadow-md);
    }

    [data-theme="dark"] .hamburger-btn,
    [data-theme="dark"] .menu-close {
        background: var(--light);
        border-color: var(--gray-dark);
        color: var(--gray);
    }
    [data-theme="dark"] .hamburger-btn:hover,
    [data-theme="dark"] .menu-close:hover {
        background: var(--light-alt);
        color: var(--primary);
    }


    .menu-content {
      position: fixed;
      top: 0;
      left: -250px; /* Start off-screen - reduced from 300px */
      width: 250px; /* Reduced from 300px */
      height: 100%;
      background-color: var(--light);
      box-shadow: var(--shadow-md);
      transition: left 0.3s ease;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--gray-light);
    }

    [data-theme="dark"] .menu-content {
      background-color: var(--light-alt);
      border-right-color: var(--gray-dark);
    }

    .menu-content.active {
      left: 0;
    }

    .menu-header {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 1.5rem;
        padding-top: 0.5rem;
    }

    .menu-close {
      /* Removed absolute positioning, now part of flow */
    }

    .menu-item-header {
      padding: 0.5rem 0;
      margin: 1rem 0 0.5rem 0;
      font-weight: 600;
      font-size: 0.8rem;
      color: var(--gray);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid var(--gray-light);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    [data-theme="dark"] .menu-item-header {
      border-color: var(--gray-dark);
      color: var(--gray);
    }

    .menu-item {
      padding: 0.75rem 0.5rem; /* Adjusted padding */
      margin: 0.25rem 0;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .menu-item span {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
    }
    .menu-item:hover {
      background-color: var(--light-alt);
    }

    [data-theme="dark"] .menu-item:hover {
      background-color: var(--light);
    }

    .completed-games-list {
      flex-grow: 1; /* Allow list to fill available space */
      overflow-y: auto;
      margin: 0.5rem 0;
      padding-right: 0.5rem; /* Space for scrollbar */
    }
    /* Custom scrollbar (optional) */
    .completed-games-list::-webkit-scrollbar { width: 6px; }
    .completed-games-list::-webkit-scrollbar-track { background: transparent; }
    .completed-games-list::-webkit-scrollbar-thumb { background: var(--gray-light); border-radius: 3px; }
    [data-theme="dark"] .completed-games-list::-webkit-scrollbar-thumb { background: var(--gray-dark); }


    .completed-game-item {
      padding: 0.75rem 1rem;
      margin: 0.5rem 0;
      background-color: var(--light-alt);
      border-radius: var(--radius);
      border-left: 3px solid var(--primary);
      transition: var(--transition);
      font-size: 0.85rem;
      cursor: pointer; /* Indicate clickable */
    }

    .completed-game-item:hover {
      transform: translateX(3px);
      background-color: var(--light);
      box-shadow: var(--shadow-sm);
    }

    [data-theme="dark"] .completed-game-item {
      background-color: var(--light);
      border-color: var(--primary);
    }

    [data-theme="dark"] .completed-game-item:hover {
      background-color: var(--light-alt);
    }

    .completed-game-item div {
      margin: 0.2rem 0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--gray);
    }
    .completed-game-item div i {
        width: 14px; /* Align icons */
        text-align: center;
    }

    .game-winner {
      color: var(--success) !important; /* Important needed to override general color */
      font-weight: 500;
    }

    .game-score {
      color: var(--primary) !important; /* Important needed */
      font-weight: 500;
    }

    [data-theme="dark"] .game-winner { color: var(--success) !important; }
    [data-theme="dark"] .game-score { color: var(--primary) !important; }

    .no-games {
      padding: 1rem;
      text-align: center;
      color: var(--gray);
      font-style: italic;
      font-size: 0.9rem;
    }

    /* Toggle switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px; /* Smaller size */
      height: 22px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--gray-light);
      transition: .3s;
      border-radius: 22px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px; /* Smaller knob */
      width: 16px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
      box-shadow: var(--shadow-sm);
    }

    input:checked + .slider {
      background-color: var(--primary);
    }

    input:checked + .slider:before {
      transform: translateX(18px); /* Adjusted translate */
    }

    [data-theme="dark"] .slider {
        background-color: var(--gray-dark);
    }

    /* Game Info / Validation Messages */
    .game-info {
      margin-bottom: 0.75rem; /* Reduced from 1rem */
      padding: 0.5rem 1rem; /* Reduced vertical padding from 0.625rem */
      background-color: var(--light-alt);
      border-radius: var(--radius);
      border: 1px solid var(--gray-light);
      color: var(--gray);
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      min-height: 36px; /* Ensure consistent height */
    }

    [data-theme="dark"] .game-info {
      background-color: var(--light);
      border-color: var(--gray-dark);
    }

    .game-info.bid-warning {
        border-left: 3px solid var(--danger);
        color: var(--danger);
        background-color: rgba(239, 68, 68, 0.05);
    }
    [data-theme="dark"] .game-info.bid-warning {
        background-color: rgba(248, 113, 113, 0.1);
    }
    .game-info.bid-ok { /* Style for valid bid total */
        border-left: 3px solid var(--success);
        color: var(--success);
        background-color: rgba(34, 197, 94, 0.05);
    }
    [data-theme="dark"] .game-info.bid-ok {
         background-color: rgba(74, 222, 128, 0.08);
    }
    .game-info.trick-ok { /* Style for valid trick total */
        border-left: 3px solid var(--success);
        color: var(--success);
        background-color: rgba(34, 197, 94, 0.05);
    }
    [data-theme="dark"] .game-info.trick-ok {
         background-color: rgba(74, 222, 128, 0.08);
    }

    /* Elimination notification banner */
    .elimination-banner {
      background-color: var(--primary);
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: var(--radius);
      font-weight: 500;
      box-shadow: var(--shadow);
      text-align: center;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      animation: fadeIn 0.3s ease-in-out;
      border: 1px solid rgba(0,0,0,0.1);
      font-size: 0.75rem;
      white-space: nowrap;
    }

    /* Original fixed position banner styling kept for compatibility */
    #elimination-banner {
      position: fixed;
      top: 4.5rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 850;
    }

    /* New inline banner styling */
    #round-elimination-banner {
      /* No position:fixed here so it stays with the content */
      z-index: 100;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -10px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }

    [data-theme="dark"] .elimination-banner {
      background-color: var(--primary);
      color: white;
    }

    .elimination-banner i {
      font-size: 0.7rem;
    }

    .button-group {
      display: flex;
      gap: 0.75rem; /* Consistent gap */
      flex-wrap: wrap;
    }

    /* Final tweaks for spacing and alignment */
    .flex-between > p { /* Style for the "Round X of 14" text */
      color: var(--gray);
      font-size: 0.9rem;
      margin-top: 0.25rem; /* Align better with buttons if wrapped */
    }

    /* Remove default focus outline, using box-shadow instead */
    *:focus {
        outline: none;
    }
    /* Add explicit focus-visible for keyboard navigation */
    *:focus-visible {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
        border-radius: var(--radius);
    }
    input:focus-visible, button:focus-visible, .toggle-switch:focus-within {
        outline: none; /* Use box-shadow for these elements */
    }
    button:focus-visible {
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4);
    }
    [data-theme="dark"] button:focus-visible {
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.5);
    }

    /* Responsive design adjustments */
    @media (max-width: 640px) { /* Adjusted breakpoint */
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 1.875rem;
        width: 80%; /* Limit width on mobile */
        line-height: 1.2;
      }

      .card {
        padding: 1.25rem;
      }

      .flex-between {
        flex-direction: column;
        align-items: stretch; /* Stretch items full width */
      }
      .flex-between > .button-group {
        width: 100%;
        justify-content: center;
      }
      .flex-between > p {
        text-align: center;
        width: 100%;
        margin-top: 0.5rem;
      }

      /* Ensure table cells don't get too cramped */
      th, td {
        padding: 0.75rem 0.5rem; /* Reduced padding */
      }
      input[type="number"] {
        width: 3.8rem; /* Slightly smaller */
        padding: 0.625rem 0.5rem;
      }
      td {
         font-size: 0.85rem;
      }
    }

    /* Disable hover effects on mobile/touch devices */
    @media (hover: none) {
      button:hover:not(:disabled),
      .btn-remove:hover,
      .btn-green:hover:not(:disabled),
      .btn-red:hover:not(:disabled),
      .btn-outline:hover:not(:disabled),
      .menu-item:hover,
      .completed-game-item:hover,
      .hamburger-btn:hover,
      .menu-close:hover,
      tbody tr:hover {
        /* Reset all hover styles */
        background-color: inherit;
        color: inherit;
        transform: none;
        box-shadow: none;
        border-color: inherit;
      }

      /* Reset specific hover states that need explicit values */
      button:hover:not(:disabled) {
        background-color: var(--primary);
      }
      .btn-green:hover:not(:disabled) {
        background-color: var(--success);
      }
      .btn-red:hover:not(:disabled) {
        background-color: var(--danger);
      }
      .btn-outline:hover:not(:disabled) {
        background-color: transparent;
        color: var(--primary);
      }
      .btn-remove:hover {
        background: none;
        color: var(--danger);
      }
      .completed-game-item:hover {
        transform: none;
        background-color: var(--light-alt);
      }
      [data-theme="dark"] .completed-game-item:hover {
        background-color: var(--light);
      }
      [data-theme="dark"] .menu-item:hover {
        background-color: transparent;
      }
    }

    /* Version indicator */
    .version-badge {
      position: fixed;
      top: 1.25rem;
      right: 1rem;
      z-index: 900;
      background-color: var(--light);
      color: var(--primary);
      border: 1px solid var(--gray-light);
      border-radius: var(--radius);
      padding: 0.25rem 0.5rem; /* Reduced padding from 0.4rem 0.75rem */
      font-size: 0.75rem; /* Reduced font size from 0.8rem */
      font-weight: 500;
      box-shadow: var(--shadow-sm);
      cursor: pointer;
      transition: var(--transition);
    }

    .version-badge:hover {
      background-color: var(--light-alt);
      box-shadow: var(--shadow);
      transform: translateY(-2px);
    }

    /* Version modal */
    .version-modal {
      position: fixed;
      top: 3.5rem;
      right: 1rem;
      z-index: 950;
      background-color: var(--light);
      border: 1px solid var(--gray-light);
      border-radius: var(--radius);
      padding: 1rem;
      width: 300px;
      max-width: calc(100vw - 2rem);
      box-shadow: var(--shadow-md);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0.2s;
    }

    .version-modal.active {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0s;
    }

    .version-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .version-title h3 {
      margin: 0;
      color: var(--dark);
    }

    .version-modal .close-btn {
      background: none;
      color: var(--gray);
      padding: 0.25rem;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      min-width: 22px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .version-modal .close-btn:hover {
      color: var(--dark);
      background-color: var(--gray-light);
    }

    .version-info {
      font-size: 0.9rem;
      color: var(--gray-dark);
    }

    .version-info p {
      margin: 0.5rem 0;
    }

    .version-info ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }

    .version-info li {
      margin: 0.25rem 0;
    }

    [data-theme="dark"] .version-badge {
      background-color: var(--light-alt);
      border-color: var(--gray-dark);
    }

    [data-theme="dark"] .version-badge:hover {
      background-color: var(--light);
    }

    [data-theme="dark"] .version-modal {
      background-color: var(--light-alt);
      border-color: var(--gray-dark);
    }

    [data-theme="dark"] .version-modal .close-btn:hover {
      background-color: var(--gray-dark);
      color: var(--light);
    }

    [data-theme="dark"] .version-info {
      color: var(--dark-alt);
    }

    /* Eliminated player style */
    .eliminated-player {
      text-decoration: line-through;
      opacity: 0.7;
      color: var(--gray);
    }

    [data-theme="dark"] .eliminated-player {
      opacity: 0.6;
    }

    /* Game Details Modal */
    .game-details-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1100;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
    }

    .game-details-modal.active {
      opacity: 1;
      visibility: visible;
    }

    .game-details-content {
      background-color: var(--light);
      border-radius: var(--radius);
      box-shadow: var(--shadow-md);
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      padding: 1.5rem;
      position: relative;
      border: 1px solid var(--gray-light);
    }

    [data-theme="dark"] .game-details-content {
      background-color: var(--light-alt);
      border-color: var(--gray-dark);
    }

    .game-details-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--gray-light);
    }

    [data-theme="dark"] .game-details-header {
      border-bottom-color: var(--gray-dark);
    }

    .game-details-close {
      background: none;
      color: var(--gray);
      border: none;
      cursor: pointer;
      font-size: 1.25rem;
      padding: 0.25rem;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .game-details-close:hover {
      background-color: var(--gray-light);
      color: var(--dark);
    }

    [data-theme="dark"] .game-details-close:hover {
      background-color: var(--gray-dark);
      color: var(--light);
    }

    .game-details-title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .game-date {
      font-size: 0.9rem;
      color: var(--gray);
      margin-bottom: 1rem;
    }

    .game-details-winners {
      background-color: var(--light-alt);
      padding: 0.75rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
      border-left: 3px solid var(--success);
    }

    [data-theme="dark"] .game-details-winners {
      background-color: var(--light);
      border-left-color: var(--success);
    }

    .game-details-winners h4 {
      margin: 0;
      font-size: 0.9rem;
      color: var(--gray);
      margin-bottom: 0.5rem;
    }

    .winner-names {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--success);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .winner-names i {
      color: var(--warning);
    }

    .player-scores-list {
      margin-top: 1rem;
    }

    .player-score-item {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid var(--gray-light);
    }

    [data-theme="dark"] .player-score-item {
      border-bottom-color: var(--gray-dark);
    }

    .player-score-item:last-child {
      border-bottom: none;
    }

    .player-score-name {
      font-weight: 500;
    }

    .player-score-value {
      font-weight: 600;
      color: var(--primary);
    }

    .player-score-item.winner {
      background-color: rgba(34, 197, 94, 0.05);
    }

    [data-theme="dark"] .player-score-item.winner {
      background-color: rgba(74, 222, 128, 0.08);
    }

    .player-score-item.eliminated {
      text-decoration: line-through;
      opacity: 0.7;
    }

    [data-theme="dark"] .player-score-item.eliminated {
      opacity: 0.6;
    }

    .player-scores-header {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      background-color: var(--light-alt);
      font-weight: 500;
      color: var(--gray);
      font-size: 0.85rem;
      border-bottom: 1px solid var(--gray-light);
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
    }

    [data-theme="dark"] .player-scores-header {
      background-color: var(--light);
      border-bottom-color: var(--gray-dark);
    }

    .player-scores-container {
      border: 1px solid var(--gray-light);
      border-radius: var(--radius);
      overflow: hidden;
    }

    [data-theme="dark"] .player-scores-container {
      border-color: var(--gray-dark);
    }

    /* Loading indicator */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        z-index: 2000; /* Ensure it's on top */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .loading-overlay.active {
        opacity: 1;
        visibility: visible;
    }
    .loading-overlay i {
        margin-right: 1rem;
    }

    /* Indicator for dealer/last player */
    .dealer-indicator, .last-player-indicator {
        font-size: 0.7rem;
        font-weight: bold;
        margin-left: 0.5rem;
        padding: 0.1rem 0.4rem;
        border-radius: var(--radius);
        vertical-align: middle;
    }
    .dealer-indicator {
        background-color: rgba(245, 158, 11, 0.1); /* Amber bg */
        color: var(--warning);
        border: 1px solid rgba(245, 158, 11, 0.3);
    }
    .last-player-indicator {
        background-color: rgba(239, 68, 68, 0.1); /* Red bg */
        color: var(--danger);
        border: 1px solid rgba(239, 68, 68, 0.3);
    }
    [data-theme="dark"] .dealer-indicator {
        background-color: rgba(251, 191, 36, 0.2);
    }
    [data-theme="dark"] .last-player-indicator {
        background-color: rgba(248, 113, 113, 0.2);
    }

    /* Style for disabled bid input for last player */
    input.bid-input:disabled {
        background-color: var(--gray-light);
        cursor: not-allowed;
        opacity: 0.7;
    }
     [data-theme="dark"] input.bid-input:disabled {
        background-color: var(--gray-dark);
    }

  </style>
</head>
<body data-theme="light">
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <i class="fas fa-spinner fa-spin"></i> Connecting...
  </div>

  <div class="fixed-header"></div>
  <div class="hamburger-menu">
    <button class="hamburger-btn" aria-label="Open menu"><i class="fas fa-bars"></i></button>
    <div class="menu-content">
      <div class="menu-header">
          <button class="menu-close" aria-label="Close menu"><i class="fas fa-times"></i></button>
      </div>

      <div class="menu-item-header">
        <i class="fas fa-cog"></i> Settings
      </div>
      <div class="menu-item">
        <span><i class="fas fa-moon"></i> Dark Mode</span>
        <label class="toggle-switch">
          <input type="checkbox" id="dark-mode-toggle" aria-label="Toggle dark mode">
          <span class="slider"></span>
        </label>
      </div>

      <div class="menu-item-header">
        <i class="fas fa-history"></i> Game History
      </div>
      <div class="completed-games-list" id="completed-games-list">
        {/* Completed games will be inserted here */}
        <div class="no-games"><i class="fas fa-info-circle"></i> Loading history...</div>
      </div>
    </div>
  </div>

  <div class="container">
    <h1>14-High! <span style="font-size: 1rem; vertical-align: middle; color: var(--secondary);">(Online)</span></h1>

    <div id="app">
      {/* Content will be dynamically inserted here */}
      {/* Placeholder while JS loads */}
      <div class="card">
          <h2>Loading Game...</h2>
          <p style="text-align: center; color: var(--gray); padding: 2rem 0;">
              <i class="fas fa-spinner fa-spin fa-2x"></i>
          </p>
          <p style="text-align: center; font-size: 0.9rem; color: var(--gray);">Waiting for connection to server...</p>
      </div>
    </div>
  </div>

  <!-- Elimination notification banner (initially hidden) -->
  <div id="elimination-banner" class="elimination-banner" style="display: none;">
    <i class="fas fa-exclamation-triangle"></i>
    <span id="elimination-message">Upcoming elimination</span>
  </div>

  <!-- Version indicator -->
  <div class="version-badge" id="version-badge">
    <span>v1.2.0-Firebase</span> <!-- Updated Version -->
  </div>

  <div class="version-modal" id="version-modal">
    <div class="version-title">
      <h3>14-High! v1.2.0-Firebase</h3>
      <button class="close-btn" id="version-close" aria-label="Close version info">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="version-info">
      <p><strong>Released:</strong> [Current Date]</p>
      <p><strong>What's New:</strong></p>
      <ul>
        <li><i class="fas fa-wifi"></i> Real-time Multiplayer via Firebase!</li>
        <li>Bids and scores update live for all players.</li>
        <li>Dealer tracking and last player bid restriction implemented.</li>
        <li>Game state is now shared across devices.</li>
        <li>Removed "Undo Round" due to multiplayer complexity.</li>
        <li>Previous offline features (history, dark mode) remain.</li>
      </ul>
      <p><strong>Features:</strong></p>
      <ul>
        <li>Real-time multiplayer scoring</li>
        <li>Auto-calculates scores</li>
        <li>Player elimination rule</li>
        <li>Dark/light mode</li>
        <li>Game history tracking (local)</li>
        <li>Mobile-friendly design</li>
      </ul>
    </div>
  </div>

  <!-- Game Details Modal -->
  <div class="game-details-modal" id="game-details-modal">
    <div class="game-details-content">
      <div class="game-details-header">
        <h3 class="game-details-title">Game Details</h3>
        <button class="game-details-close" id="game-details-close" aria-label="Close game details">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div id="game-details-body">
        <!-- Dynamic content will be inserted here -->
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

  <script>
    // --- Firebase Configuration ---
    // IMPORTANT: Replace with your actual Firebase config
    const firebaseConfig = {
  apiKey: "AIzaSyAwrUIh07PQwXP4w_UtA_GWqY1BnI-29fA",
  authDomain: "asphalt-yield-calculator.firebaseapp.com",
  databaseURL: "https://asphalt-yield-calculator-default-rtdb.firebaseio.com",
  projectId: "asphalt-yield-calculator",
  storageBucket: "asphalt-yield-calculator.firebasestorage.app",
  messagingSenderId: "976877514620",
  appId: "1:976877514620:web:cc15b1bdaf19c4a53b7ef9",
  measurementId: "G-NM5V8EXM44"
};

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const gameRef = database.ref('game'); // Reference to the shared game state node

    // Set security rules programmatically (this is just for demonstration - you should set these in the Firebase console)
    // You need to go to the Firebase console and set these rules manually:
    // {
    //   "rules": {
    //     ".read": "auth != null || true", 
    //     ".write": "auth != null || true"
    //   }
    // }

    // --- Local State (acts as a cache of Firebase data) ---
    let state = {
      players: [],
      gameStarted: false,
      currentRound: 1,
      dealerIndex: 0, // Index of the dealer in the players array
      bids: {},
      tricks: {},
      scores: {},
      bidPhase: true,
      eliminatedPlayers: [],
      // Completed games remain local to each device for now
      completedGames: JSON.parse(localStorage.getItem('completedGames')) || []
    };

    // --- DOM Elements ---
    const app = document.getElementById('app');
    const hamburgerBtn = document.querySelector('.hamburger-btn');
    const menuContent = document.querySelector('.menu-content');
    const menuClose = document.querySelector('.menu-close');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const completedGamesList = document.getElementById('completed-games-list');
    const body = document.body;
    const versionBadge = document.getElementById('version-badge');
    const versionModal = document.getElementById('version-modal');
    const versionClose = document.getElementById('version-close');
    const eliminationBanner = document.getElementById('elimination-banner');
    const loadingOverlay = document.getElementById('loading-overlay');
    const gameDetailsModal = document.getElementById('game-details-modal');
    const gameDetailsClose = document.getElementById('game-details-close');
    const gameDetailsBody = document.getElementById('game-details-body');

    // --- Initialization ---
    let firebaseConnected = false;
    let initialDataLoaded = false;
    previousHtml = ''; // Track previous HTML to avoid unnecessary re-renders

    // Show loading overlay initially
    loadingOverlay.classList.add('active');

    // Load theme preference (remains local)
    function applyTheme(theme) {
      body.setAttribute('data-theme', theme);
      darkModeToggle.checked = theme === 'dark';
      localStorage.setItem('theme', theme);
    }
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    applyTheme(savedTheme || (prefersDark ? 'dark' : 'light'));

    // --- Firebase Listener ---
    gameRef.on('value', (snapshot) => {
      firebaseConnected = true;
      const firebaseState = snapshot.val();

      // Update local state with data from Firebase
      if (firebaseState) {
        // Merge Firebase state into local state, preserving local-only parts
        state = {
          ...state, // Keep local completedGames, etc.
          players: firebaseState.players || [],
          gameStarted: firebaseState.gameStarted || false,
          currentRound: firebaseState.currentRound || 1,
          dealerIndex: firebaseState.dealerIndex === undefined ? 0 : firebaseState.dealerIndex, // Default dealerIndex to 0 if not set
          bids: firebaseState.bids || {},
          tricks: firebaseState.tricks || {},
          scores: firebaseState.scores || {},
          bidPhase: firebaseState.bidPhase === undefined ? true : firebaseState.bidPhase, // Default bidPhase to true
          eliminatedPlayers: firebaseState.eliminatedPlayers || []
        };
        console.log('Firebase data received:', state);
      } else {
        // Handle case where database node is empty (e.g., first load or after reset)
        console.log('Firebase data empty, resetting local state.');
        state = {
          players: [],
          gameStarted: false,
          currentRound: 1,
          dealerIndex: 0,
          bids: {},
          tricks: {},
          scores: {},
          bidPhase: true,
          eliminatedPlayers: [],
          completedGames: state.completedGames // Keep local history
        };
        // Optional: Initialize Firebase with default state if it's truly empty
        // gameRef.set(getFirebaseSafeState());
      }

      if (!initialDataLoaded) {
        initialDataLoaded = true;
        loadingOverlay.classList.remove('active'); // Hide loading only after first data load
        console.log('Initial data loaded, rendering app.');
      }

      // Render the application with the updated state
      renderApp();
      checkUpcomingElimination(); // Re-check elimination status after state update

    }, (error) => {
      console.error("Firebase read failed: " + error.code);
      loadingOverlay.innerHTML = '<i class="fas fa-times-circle"></i> Connection Failed';
      // Keep loading overlay visible on error
      firebaseConnected = false;
    });

    // Monitor connection status (optional, for better UX)
    database.ref(".info/connected").on("value", (snap) => {
      if (snap.val() === true) {
        console.log("Firebase connected.");
        if (initialDataLoaded) loadingOverlay.classList.remove('active'); // Hide if already loaded data
      } else {
        console.log("Firebase disconnected.");
        if (!initialDataLoaded) { // If data never loaded, show connection issue
           loadingOverlay.innerHTML = '<i class="fas fa-wifi"></i> Disconnected. Trying to reconnect...';
           loadingOverlay.classList.add('active');
        }
        firebaseConnected = false;
      }
    });


    // Initial render for local elements (history)
    renderCompletedGames();


    // --- Event Listeners ---

    // Hamburger menu toggle
    hamburgerBtn.addEventListener('click', (e) => {
      menuContent.classList.add('active');
      menuClose.focus();
      e.stopPropagation();
    });

    menuClose.addEventListener('click', () => {
      menuContent.classList.remove('active');
      hamburgerBtn.focus();
    });

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      if (menuContent.classList.contains('active') &&
          !menuContent.contains(e.target) &&
          e.target !== hamburgerBtn &&
          !hamburgerBtn.contains(e.target)) {
        menuContent.classList.remove('active');
      }
    });

    // Trap focus within the menu when open
    menuContent.addEventListener('keydown', (e) => { /* ... (no changes needed) ... */ });

    // Close modals with Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (menuContent.classList.contains('active')) {
                menuContent.classList.remove('active');
                hamburgerBtn.focus();
            }
            if (versionModal.classList.contains('active')) {
                versionModal.classList.remove('active');
                versionBadge.focus();
            }
            if (gameDetailsModal.classList.contains('active')) {
                gameDetailsModal.classList.remove('active');
            }
        }
    });


    // Dark mode toggle (local setting)
    darkModeToggle.addEventListener('change', () => {
      applyTheme(darkModeToggle.checked ? 'dark' : 'light');
    });

    // Version badge toggle
    versionBadge.addEventListener('click', (e) => {
      versionModal.classList.add('active');
      e.stopPropagation();
    });

    versionClose.addEventListener('click', () => {
      versionModal.classList.remove('active');
    });

    // Close version modal when clicking outside
    document.addEventListener('click', (e) => {
      if (versionModal.classList.contains('active') &&
          !versionModal.contains(e.target) &&
          e.target !== versionBadge) {
        versionModal.classList.remove('active');
      }
    });

     // Game Details Modal Listeners
    gameDetailsClose.addEventListener('click', () => {
      gameDetailsModal.classList.remove('active');
    });
    gameDetailsModal.addEventListener('click', (e) => {
      if (e.target === gameDetailsModal) {
        gameDetailsModal.classList.remove('active');
      }
    });
    // Add click listeners to completed game items dynamically
    completedGamesList.addEventListener('click', (e) => {
        const gameItem = e.target.closest('.completed-game-item');
        if (gameItem) {
            const gameIndex = parseInt(gameItem.getAttribute('data-game-index'));
             if (!isNaN(gameIndex)) {
                showGameDetails(gameIndex);
            }
        }
    });


    // Setup event listeners for dynamic elements (using event delegation on #app)
    app.addEventListener('click', (e) => {
        // Player Setup
        if (e.target.closest('#add-player-btn')) addPlayer();
        if (e.target.closest('#start-game-btn')) startGame();
        const removeBtn = e.target.closest('.btn-remove');
        if (removeBtn) {
            const player = removeBtn.getAttribute('data-player');
            if (player) removePlayer(player);
        }

        // Gameplay
        if (e.target.closest('#submit-bids-btn')) submitBids();
        if (e.target.closest('#submit-results-btn')) submitRoundResults();
        if (e.target.closest('#reset-game-btn')) resetGame();
        // Undo button removed
    });

    app.addEventListener('keypress', (e) => {
        // Player Setup: Add player on Enter
        if (e.target.id === 'player-name' && e.key === 'Enter') {
            e.preventDefault();
            addPlayer();
        }
        // Gameplay: Handle Enter on inputs (No changes needed here, focus logic is fine)
        // ... (existing keypress logic for inputs) ...
        if (e.key === 'Enter') {
            const bidInput = e.target.closest('.bid-input');
            const trickInput = e.target.closest('.trick-input');
            const activeElement = document.activeElement; // Store focused element

            if (bidInput) {
                e.preventDefault();
                const player = bidInput.getAttribute('data-player');
                const value = bidInput.value; // Get value before potential update
                if (player && value !== '' && !bidInput.disabled) {
                    // Attempt to find the next enabled bid input
                    const allBidInputs = Array.from(app.querySelectorAll('.bid-input'));
                    const currentIndex = allBidInputs.findIndex(input => input === bidInput);
                    let nextInput = null;
                    for (let i = currentIndex + 1; i < allBidInputs.length; i++) {
                        if (!allBidInputs[i].disabled) {
                            nextInput = allBidInputs[i];
                            break;
                        }
                    }

                    if (nextInput) {
                        nextInput.focus();
                        nextInput.select();
                    } else if (allBidsEntered(state)) { // Check if *now* all bids are entered
                       submitBids(); // Submit if last input and valid
                    }
                }
            } else if (trickInput) {
                e.preventDefault();
                const player = trickInput.getAttribute('data-player');
                const value = trickInput.value;
                 if (player && value !== '') {
                    const nextInput = trickInput.closest('tr')?.nextElementSibling?.querySelector('.trick-input');
                     if (nextInput) {
                        nextInput.focus();
                        nextInput.select();
                    } else if (allTricksEntered(state) && validateTricksTotal(state)) {
                        submitRoundResults(); // Submit if last input and valid
                    }
                }
            }
        }
    });

    app.addEventListener('input', (e) => {
        // Gameplay: Handle live input changes for validation AND writing to Firebase
        const bidInput = e.target.closest('.bid-input');
        const trickInput = e.target.closest('.trick-input');

        if (bidInput && !bidInput.disabled) { // Check if disabled (last player restriction)
            const player = bidInput.getAttribute('data-player');
            const value = bidInput.value;
             // Allow empty string during typing, validate on write/check
            const bidValue = value === '' ? null : parseInt(value); // Store null if empty

             if (player) {
                if (bidValue !== null && (isNaN(bidValue) || bidValue < 0 || bidValue > state.currentRound)) {
                    // Basic client-side validation for range
                    bidInput.value = state.bids[player] || ''; // Revert to previous valid state value
                    return;
                }
                // Check last player restriction *before* writing
                if (isLastPlayer(player, state)) {
                    const potentialTotal = calculatePotentialBidTotal(player, bidValue, state);
                    if (potentialTotal === state.currentRound) {
                        // Visually indicate error, but don't write invalid state
                         // Maybe flash border red?
                         console.warn("Last player bid invalid - total would match round");
                         // We don't revert input here, let the validation message guide the user
                         // And the submit button will remain disabled by allBidsEntered check
                         updateValidationAndButtons(); // Update UI feedback
                         return; // Don't write to firebase
                    }
                }

                // Write valid bid to Firebase
                gameRef.child('bids').child(player).set(bidValue)
                   .catch(err => console.error("Firebase bid write failed:", err));
                // The Firebase listener will update local state and re-render,
                // but we can call updateValidationAndButtons immediately for faster UI feedback
                updateValidationAndButtons();
             }
        } else if (trickInput) {
            const player = trickInput.getAttribute('data-player');
            const value = trickInput.value;
            const tricksValue = value === '' ? null : parseInt(value); // Store null if empty

             if (player) {
                 if (tricksValue !== null && (isNaN(tricksValue) || tricksValue < 0 || tricksValue > 14)) {
                    trickInput.value = state.tricks[player] || ''; // Revert
                    return;
                 }
                // Write trick to Firebase
                 gameRef.child('tricks').child(player).set(tricksValue)
                    .catch(err => console.error("Firebase trick write failed:", err));
                 updateValidationAndButtons(); // Faster UI feedback
             }
        }
    });

    // Select input content on focus
    app.addEventListener('focusin', (e) => {
        if (e.target.matches('input[type="number"]') || e.target.matches('input[type="text"]')) {
            e.target.select();
        }
    });


    // --- Core Rendering Logic ---

    function renderApp() {
       // Render based on the local 'state' which is updated by Firebase
      if (!firebaseConnected && !initialDataLoaded) {
         // Still waiting for initial connection/data
         // Keep the initial loading message in #app
         return;
      }

      let newHtml = '';

      if (!state.gameStarted) {
        newHtml = renderPlayerSetup(state);
      } else {
        newHtml = renderGameplay(state);
      }

      // Simple diffing to reduce full re-renders
      if (newHtml !== previousHtml) {
        app.innerHTML = newHtml;
        previousHtml = newHtml;

         // Set focus after render if needed
         if (!state.gameStarted) {
            const playerNameInput = document.getElementById('player-name');
            if (playerNameInput) playerNameInput.focus();
        }
        // Focus logic for bid/trick inputs might need adjustment
        // due to asynchronous nature and potential input disabling.
        // Let's rely on manual focus or standard tab order for now.

        // Update inline elimination banner after DOM is updated
        if (state.gameStarted && state.currentRound <= 14) {
          setTimeout(checkUpcomingElimination, 0); // Use setTimeout to ensure DOM is ready
        }
      }
       // Always update validation state after any render potentially caused by Firebase
      updateValidationAndButtons();
    }

    // Function to update only validation messages and button states without full re-render
    function updateValidationAndButtons() {
        if (!state.gameStarted || state.currentRound > 14) return;

        const totalBids = calculateTotalBids(state.bids);
        const totalTricks = calculateTotalTricks(state.tricks);
        const lastPlayer = getLastPlayerName(state);
        const lastPlayerBid = (lastPlayer && state.bids[lastPlayer] !== undefined && state.bids[lastPlayer] !== null) ? state.bids[lastPlayer] : undefined;

        // --- Update Bid Info/Warning ---
        const bidInfoEl = document.getElementById('bid-info');
        if (bidInfoEl && state.bidPhase) {
             if (allPlayersHaveBid(state)) {
                 if (totalBids === state.currentRound) {
                     bidInfoEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Invalid: Total bids cannot equal ${state.currentRound} (currently ${totalBids}). ${lastPlayer ? escapeHtml(lastPlayer) + ' must change bid.' : ''}`;
                     bidInfoEl.className = 'game-info bid-warning';
                 } else {
                    bidInfoEl.innerHTML = `<i class="fas fa-check-circle"></i> Valid Bids: Total ${totalBids}`;
                    bidInfoEl.className = 'game-info bid-ok';
                 }
             } else {
                bidInfoEl.innerHTML = `<i class="fas fa-info-circle"></i> Total bids: ${totalBids} / ${state.currentRound}. Waiting for all bids.`;
                bidInfoEl.className = 'game-info'; // Neutral style
             }
        }

        // --- Update Trick Info/Warning ---
        const trickInfoEl = document.getElementById('trick-info');
         if (trickInfoEl && !state.bidPhase) {
             if (allPlayersHaveTricks(state)) {
                 if (totalTricks !== state.currentRound) {
                     trickInfoEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Invalid: Total hands must equal ${state.currentRound} (currently ${totalTricks})`;
                     trickInfoEl.className = 'game-info bid-warning'; // Use same warning style
                 } else {
                    trickInfoEl.innerHTML = `<i class="fas fa-check-circle"></i> Valid Hands: Total ${totalTricks}`;
                    trickInfoEl.className = 'game-info trick-ok'; // Use success style
                 }
             } else {
                  trickInfoEl.innerHTML = `<i class="fas fa-info-circle"></i> Total hands: ${totalTricks} / ${state.currentRound}. Waiting for all results.`;
                  trickInfoEl.className = 'game-info'; // Neutral style
             }
         }

        // --- Update Button States ---
        const submitBidsBtn = document.getElementById('submit-bids-btn');
        if (submitBidsBtn) {
            submitBidsBtn.disabled = !allBidsEntered(state); // Use validation helper
        }
        const submitResultsBtn = document.getElementById('submit-results-btn');
        if (submitResultsBtn) {
            submitResultsBtn.disabled = !(allTricksEntered(state) && validateTricksTotal(state)); // Use validation helpers
        }

        // --- Update Last Player Input Disabled State ---
        if (state.bidPhase && lastPlayer) {
            const lastPlayerInput = document.querySelector(`.bid-input[data-player="${escapeHtml(lastPlayer)}"]`);
            if (lastPlayerInput) {
                 // Should the input be disabled? Only if *other* players' bids are set
                 // such that *any* bid by the last player would make the total equal the round number.
                 // This is complex. A simpler rule: Disable if *all other* players have bid.
                 let disableLastPlayer = false;
                 let otherPlayersBidsTotal = 0;
                 let allOthersHaveBid = true;
                 state.players.forEach(p => {
                     if (p !== lastPlayer) {
                         if (state.bids[p] === undefined || state.bids[p] === null) {
                             allOthersHaveBid = false;
                         } else {
                             otherPlayersBidsTotal += state.bids[p];
                         }
                     }
                 });

                 // If all others have bid, check if the only valid bid for the last player is impossible
                 if(allOthersHaveBid) {
                    const requiredBid = state.currentRound - otherPlayersBidsTotal;
                    // The last player CANNOT bid 'requiredBid'. Check if this required bid is within the possible range (0 to currentRound)
                    if (requiredBid >= 0 && requiredBid <= state.currentRound) {
                        // This means the last player is FORCED to bid something other than 'requiredBid'.
                        // The input itself remains enabled, but the validation logic handles the restriction.
                        // We don't need to disable the input based on this logic, only based on whether they *can* bid yet.
                        // Let's refine: Disable only if it's NOT their turn conceptually (though we don't enforce turns here).
                        // Sticking to the original spec: Anyone EXCEPT last player can make the total equal the round.
                        // So, the last player's input only needs validation, not disabling based on others' bids.
                        lastPlayerInput.disabled = false;
                    } else {
                        // The required bid is impossible anyway, so the last player can bid anything (0-round).
                         lastPlayerInput.disabled = false;
                    }
                 } else {
                    // Not all other players have bid yet.
                    lastPlayerInput.disabled = false;
                 }

                 // However, let's ensure the live validation message is updated if the current *entered* value is bad
                 if (lastPlayerBid !== undefined) {
                     const currentTotal = calculateTotalBids(state.bids);
                     if (currentTotal === state.currentRound) {
                         // If the current state (reflected from input) is bad, show the warning.
                         // The 'updateValidationAndButtons' function already handles the bid-info message.
                     }
                 }
            }
        }
    }


    // --- Rendering Components ---

    function renderPlayerSetup(currentState) {
      // Check if another game is in progress on the server
      const gameIsActive = currentState.gameStarted;
      return `
        <div class="card">
          <h2><i class="fas fa-users-cog"></i> Player Setup</h2>

          ${gameIsActive ? `
            <div class="game-info bid-warning">
              <i class="fas fa-exclamation-triangle"></i>
              A game is currently in progress or players are already set up on the server.
              You can join by waiting or reset the game (affects everyone).
            </div>
            <div class="player-list">
              ${currentState.players.length > 0 ? currentState.players.map(player => `
                 <div class="player-item">
                   <span>${escapeHtml(player)} ${currentState.gameStarted && getDealerName(currentState) === player ? '<span class="dealer-indicator">D</span>' : ''}</span>
                   <span>${currentState.scores[player] || 0} pts</span>
                 </div>
               `).join('') : '<p>No players yet.</p>'}
            </div>
             <button id="reset-game-btn" class="btn-full btn-red">
                <i class="fas fa-power-off"></i> Reset Game for Everyone
             </button>
          ` : `
            <div class="input-group">
              <div class="input-with-button">
                <input type="text" id="player-name" placeholder="Enter your player name" aria-label="Player name">
                <button class="btn-add" id="add-player-btn"><i class="fas fa-plus"></i> Add Player</button>
              </div>
            </div>

            ${currentState.players.length > 0 ? `
              <div>
                <h3><i class="fas fa-list-ul"></i> Current Players (${currentState.players.length})</h3>
                <div class="player-list">
                  ${currentState.players.map(player => `
                    <div class="player-item">
                      <span>${escapeHtml(player)}</span>
                      <button class="btn-remove" data-player="${escapeHtml(player)}" aria-label="Remove ${escapeHtml(player)}">
                          <i class="fas fa-times"></i>
                      </button>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : '<p style="text-align: center; color: var(--gray); font-size: 0.9rem; margin: 1.5rem 0;">No players added yet. Add 2 or more to start.</p>'}

            <button
              id="start-game-btn"
              class="btn-full btn-green"
              ${currentState.players.length < 2 ? 'disabled' : ''}
            >
              <i class="fas fa-play"></i>
              ${currentState.players.length < 2
                ? 'Need at least 2 players'
                : `Start Game (${currentState.players.length} Players)`}
            </button>
          `}
        </div>
      `;
    }

    function renderGameplay(currentState) {
      let gameplayHtml = '';
      const dealerName = getDealerName(currentState);
      const lastPlayerName = getLastPlayerName(currentState);

      // --- Round Input / Game Over ---
      if (currentState.currentRound <= 14) {
         // These calculations are now done in updateValidationAndButtons
         const bidInfoHtml = currentState.bidPhase ? '<div id="bid-info" class="game-info"></div>' : '';
         const tricksInfoHtml = !currentState.bidPhase ? '<div id="trick-info" class="game-info"></div>' : '';

        gameplayHtml += `
          <div class="card">
            <div class="flex-between" style="margin-bottom: 0.25rem;">
              <h2><i class="fas fa-tasks"></i> Round ${currentState.currentRound} / 14</h2>
              <div style="display: flex; align-items: center; gap: 0.75rem;">
                 <span class="game-status">${currentState.bidPhase ? 'Bidding Phase' : 'Enter Hands Won'}</span>
                 ${dealerName ? `<span class="game-status" style="background-color: rgba(245,158,11,0.1); color: var(--warning); border: 1px solid rgba(245,158,11,0.3);"><i class="fas fa-star"></i> Dealer: ${escapeHtml(dealerName)}</span>`: ''}
                <div id="round-elimination-banner" style="display: none;" class="elimination-banner">
                  <i class="fas fa-exclamation-triangle"></i>
                  <span id="round-elimination-message">Upcoming elimination</span>
                </div>
              </div>
            </div>

            ${currentState.bidPhase ? bidInfoHtml : tricksInfoHtml}

            <div class="table-container">
              <table>
                <thead>
                  <tr>
                    <th>Player</th>
                    <th>Bid</th>
                    ${!currentState.bidPhase ? '<th>Hands Won</th>' : ''}
                    <th>Score</th>
                  </tr>
                </thead>
                <tbody>
                  ${currentState.players.map(player => {
                    const isDealer = player === dealerName;
                    const isLast = player === lastPlayerName;
                    const bidValue = currentState.bids[player] ?? ''; // Use ?? for null/undefined check
                    const trickValue = currentState.tricks[player] ?? '';

                    // Determine if the last player's bid input should be validated (it's always enabled unless turn logic added)
                    let lastPlayerInfo = '';
                    if (currentState.bidPhase && isLast) {
                        lastPlayerInfo = '<span class="last-player-indicator">Last</span>';
                    }
                    const dealerIndicator = isDealer ? '<span class="dealer-indicator">D</span>' : '';
                    const isEliminated = currentState.eliminatedPlayers.includes(player); // Check if player is eliminated

                    // If eliminated, don't show inputs
                    if (isEliminated) {
                       return `
                         <tr class="eliminated-player">
                           <td>${escapeHtml(player)} <i class="fas fa-user-slash"></i></td>
                           <td>${currentState.bids[player] ?? '-'}</td>
                           ${!currentState.bidPhase ? `<td>${currentState.tricks[player] ?? '-'}</td>` : ''}
                           <td>${currentState.scores[player] || 0}</td>
                         </tr>
                       `;
                    }

                    // Render active player row
                    return `
                    <tr>
                      <td>${escapeHtml(player)} ${dealerIndicator} ${lastPlayerInfo}</td>
                      <td>
                        ${currentState.bidPhase
                          ? `<input type="number" min="0" max="${currentState.currentRound}" value="${bidValue}"
                               class="bid-input" data-player="${escapeHtml(player)}" aria-label="${escapeHtml(player)} bid"
                               inputmode="numeric" pattern="[0-9]*">`
                          : `<span class="badge badge-blue">${bidValue === '' ? '?' : bidValue}</span>`}
                      </td>
                      ${!currentState.bidPhase
                        ? `<td class="trick-value">
                            <input type="number" min="0" max="14" value="${trickValue}"
                             class="trick-input" data-player="${escapeHtml(player)}" aria-label="${escapeHtml(player)} hands won"
                             inputmode="numeric" pattern="[0-9]*">
                          </td>`
                        : ''}
                      <td><span class="score-value">${currentState.scores[player] || 0}</span></td>
                    </tr>
                  `}).join('')}
                </tbody>
              </table>
            </div>

            ${currentState.bidPhase
              ? `<button
                  id="submit-bids-btn"
                  class="btn-full"
                  ${!allBidsEntered(currentState) ? 'disabled' : ''}
                >
                  <i class="fas fa-check-circle"></i> Confirm Bids
                </button>`
              : `<button
                  id="submit-results-btn"
                  class="btn-full btn-green"
                  ${!(allTricksEntered(currentState) && validateTricksTotal(currentState)) ? 'disabled' : ''}
                >
                  <i class="fas fa-flag-checkered"></i> Submit Round ${currentState.currentRound} Results
                </button>`
            }
          </div>
        `;
      } else { // Game Over
        const winners = getWinners(currentState);
        gameplayHtml += `
          <div class="card">
            <h2><i class="fas fa-trophy"></i> Game Over!</h2>

            ${winners.length > 0
              ? `<div class="winner-display">
                  <h3>${winners.length === 1 ? 'Winner' : 'Winners (Tie)'}</h3>
                  <div class="winner-name">
                    <i class="fas fa-crown"></i> ${winners.map(escapeHtml).join(' & ')}
                  </div>
                  <p>${currentState.scores[winners[0]] || 0} points</p>
                </div>`
              : '<p>Error determining winner.</p>'}
             <button id="reset-game-btn" class="btn-full btn-red">
                <i class="fas fa-power-off"></i> Start New Game
             </button>
          </div>
        `;
      }

      // --- Scoreboard & Actions ---
      // Display all players including eliminated ones
      const allPlayersForScoreboard = [...new Set([...currentState.players, ...currentState.eliminatedPlayers])];
      const sortedPlayers = getSortedPlayers(currentState.scores, allPlayersForScoreboard);

      gameplayHtml += `
        <div class="card">
          <h2><i class="fas fa-clipboard-list"></i> Scoreboard</h2>

          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Player</th>
                  <th>Score</th>
                </tr>
              </thead>
              <tbody>
                ${sortedPlayers.map((player, index) => {
                    const rank = index + 1;
                    const isEliminated = currentState.eliminatedPlayers.includes(player);
                    const isWinner = currentState.currentRound > 14 && getWinners(currentState).includes(player);
                    let medal = '';
                    if (rank === 1) medal = '<i class="fas fa-medal" style="color: #d4af37;"></i>'; // Gold
                    else if (rank === 2) medal = '<i class="fas fa-medal" style="color: #c0c0c0;"></i>'; // Silver
                    else if (rank === 3) medal = '<i class="fas fa-medal" style="color: #cd7f32;"></i>'; // Bronze

                    return `
                  <tr class="${isWinner ? 'winner-row' : ''} ${isEliminated ? 'eliminated-player' : ''}">
                    <td>${rank} ${medal}</td>
                    <td>${escapeHtml(player)} ${isEliminated ? '<i class="fas fa-user-slash" title="Eliminated"></i>' : ''}</td>
                    <td>${currentState.scores[player] || 0}</td>
                  </tr>
                `}).join('')}
              </tbody>
            </table>
          </div>
        </div>

        ${currentState.currentRound <= 14 ? `
            <div class="flex-between">
              <div class="button-group">
                <button id="reset-game-btn" class="btn-red"><i class="fas fa-power-off"></i> Reset Game</button>
                {/* Undo button removed for multiplayer */}
              </div>
              <p>Round ${currentState.currentRound} / 14</p>
            </div>
            ` : '' // Don't show reset button again if already shown in game over section
        }

      `;

      return gameplayHtml;
    }

    function renderCompletedGames() {
        // This remains local storage based
      if (!completedGamesList) return;

      const localCompletedGames = JSON.parse(localStorage.getItem('completedGames')) || [];
      state.completedGames = localCompletedGames; // Sync local state copy

      completedGamesList.innerHTML = localCompletedGames.length > 0
        ? localCompletedGames.slice().reverse().map((game, index) => {
            const originalIndex = localCompletedGames.length - 1 - index; // Index in the non-reversed array
            const elimCount = game.eliminatedPlayers && game.eliminatedPlayers.length ?
                              `<span style="color: var(--danger)"><i class="fas fa-user-slash"></i> ${game.eliminatedPlayers.length}</span>` : '';

            const allParticipants = [...new Set([...(game.players || []), ...(game.eliminatedPlayers || [])])];

            return `<div class="completed-game-item" data-game-index="${originalIndex}">
                        <div><i class="fas fa-calendar-alt"></i> ${new Date(game.date).toLocaleDateString()} ${new Date(game.date).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}</div>
                        <div class="game-winner"><i class="fas fa-trophy"></i> ${game.winners.map(escapeHtml).join(' & ')}</div>
                        <div class="game-score"><i class="fas fa-star"></i> ${game.score} points</div>
                        <div style="font-size: 0.8rem;">
                        <i class="fas fa-users"></i> ${allParticipants.length} Players ${elimCount ? `(${elimCount} Eliminated)` : ''}
                        </div>
                    </div>`;
        }).join('')
        : '<div class="no-games"><i class="fas fa-folder-open"></i> No completed games yet</div>';
    }

    // --- Player Management (Writing to Firebase) ---
    function addPlayer() {
      if (!firebaseConnected) { alert("Not connected to the server."); return; }
      if (state.gameStarted) { alert("Cannot add players after the game has started."); return; }

      const playerNameInput = document.getElementById('player-name');
      if (!playerNameInput) return;
      let playerName = playerNameInput.value.trim();

      if (playerName.length > 0) {
        playerName = playerName.charAt(0).toUpperCase() + playerName.slice(1);
      }

      if (playerName && !state.players.includes(playerName)) {
        if (state.players.length >= 56) {
            alert("Maximum of 56 players allowed.");
            return;
        }
        // Prepare update for Firebase
        const updatedPlayers = [...state.players, playerName];
        const updates = {};
        updates['/players'] = updatedPlayers;
        updates[`/scores/${playerName}`] = 0; // Initialize score
        updates[`/bids/${playerName}`] = null; // Initialize bid slot
        updates[`/tricks/${playerName}`] = null; // Initialize trick slot

        gameRef.update(updates)
          .then(() => {
            playerNameInput.value = ''; // Clear input on success
            console.log(`Player ${playerName} added.`);
            // State update and re-render happens via Firebase listener
          })
          .catch(err => {
            console.error("Failed to add player:", err);
            alert("Error adding player. Please try again.");
          });

      } else if (state.players.includes(playerName)) {
          alert(`Player "${escapeHtml(playerName)}" already exists!`);
          playerNameInput.select();
      } else {
          playerNameInput.focus();
      }
    }

    function removePlayer(playerToRemove) {
       if (!firebaseConnected) { alert("Not connected to the server."); return; }
       if (state.gameStarted) { alert("Cannot remove players after the game has started."); return; }

      const updatedPlayers = state.players.filter(player => player !== playerToRemove);
      const updates = {};
      updates['/players'] = updatedPlayers;
      updates[`/scores/${playerToRemove}`] = null; // Remove score
      updates[`/bids/${playerToRemove}`] = null; // Remove bid
      updates[`/tricks/${playerToRemove}`] = null; // Remove trick
      // Adjust dealer index if the removed player was before or was the dealer
      let newDealerIndex = state.dealerIndex;
      const removedPlayerIndex = state.players.indexOf(playerToRemove);
       if (removedPlayerIndex !== -1 && removedPlayerIndex < state.dealerIndex) {
           newDealerIndex--; // Dealer shifts down if someone before them is removed
       }
       // Ensure index stays valid (it might become invalid if the dealer was the one removed, handled below)
       newDealerIndex = newDealerIndex % Math.max(1, updatedPlayers.length); // Use max(1,...) to avoid modulo by zero
       updates['/dealerIndex'] = newDealerIndex;


      gameRef.update(updates)
        .then(() => {
          console.log(`Player ${playerToRemove} removed.`);
          // State update and re-render happens via Firebase listener
        })
        .catch(err => {
          console.error("Failed to remove player:", err);
          alert("Error removing player. Please try again.");
        });
    }

    // --- Game Logic (Writing to Firebase) ---
    function startGame() {
      if (!firebaseConnected) { alert("Not connected to the server."); return; }
      if (state.players.length < 2) { alert("Need at least 2 players to start."); return; }

      const initialScores = {};
      const initialBids = {};
      const initialTricks = {};
      state.players.forEach(player => {
        initialScores[player] = 0;
        initialBids[player] = null; // Use null for empty state in Firebase
        initialTricks[player] = null;
      });

      const newState = {
        gameStarted: true,
        currentRound: 1,
        dealerIndex: 0, // Start with the first player as dealer
        bidPhase: true,
        scores: initialScores,
        bids: initialBids,
        tricks: initialTricks,
        eliminatedPlayers: [], // Reset eliminated players
        players: state.players // Keep current players
      };

      gameRef.set(newState) // Overwrite entire game node to start fresh
        .then(() => {
            console.log("Game started!");
            // Check eliminations at game start based on initial player count
            // (The listener will trigger checkElimination via renderApp)
            checkUpcomingElimination(); // Check upcoming needed after state change
        })
        .catch(err => {
            console.error("Failed to start game:", err);
            alert("Error starting game. Please try again.");
        });
    }

    // Bid/Trick changes are handled directly in the 'input' event listener

    function submitBids() {
      if (!firebaseConnected) { alert("Not connected to the server."); return; }
      if (!allBidsEntered(state)) {
          alert("Please ensure all active players have entered a valid bid, and the total bids do not equal the current round number.");
          return;
      }

      // Just need to update the bidPhase
      gameRef.child('bidPhase').set(false)
        .then(() => console.log("Bids submitted, proceeding to tricks phase."))
        .catch(err => {
            console.error("Failed to submit bids:", err);
            alert("Error submitting bids. Please try again.");
        });
    }

     function checkElimination(currentScores, activePlayers, currentRound) {
        const threshold = 56;
        const product = activePlayers.length * currentRound;

        if (product > threshold && activePlayers.length > 1) {
            // Find the player(s) with the lowest score among active players
            let lowestScore = Infinity;
            activePlayers.forEach(player => {
                const score = currentScores[player] || 0;
                if (score < lowestScore) {
                    lowestScore = score;
                }
            });

            // Get all active players with the lowest score
            const lowestPlayers = activePlayers.filter(player => (currentScores[player] || 0) === lowestScore);

            // If there's a tie for lowest score, eliminate just one (e.g., the first one found)
            const playerToEliminate = lowestPlayers[0];

            if (playerToEliminate) {
                 console.log(`Eliminating player: ${playerToEliminate} with score ${lowestScore}`);
                 alert(`Player "${escapeHtml(playerToEliminate)}" has been eliminated due to having the lowest score (${lowestScore} points)!`);
                 return playerToEliminate; // Return name of eliminated player
            }
        }
        return null; // No elimination
    }


    function submitRoundResults() {
       if (!firebaseConnected) { alert("Not connected to the server."); return; }
       if (!allTricksEntered(state) || !validateTricksTotal(state)) {
            alert("Please ensure all active players have entered hands won, and the total equals the current round number.");
            return;
       }

       // Calculate scores locally based on current (synced) state
       const currentScores = { ...state.scores }; // Copy scores
       const activePlayers = state.players; // Players currently in the game

       activePlayers.forEach(player => {
           const playerBid = state.bids[player];
           const playerTricks = state.tricks[player];
           let roundScore = 0;

           // Only calculate if bid and tricks are valid numbers
           if (typeof playerBid === 'number' && typeof playerTricks === 'number') {
               if (playerBid === playerTricks) {
                   roundScore = playerBid === 0 ? 10 : playerTricks + (10 * playerBid);
               } else {
                   roundScore = playerTricks;
               }
               currentScores[player] = (currentScores[player] || 0) + roundScore;
           } else {
               console.warn(`Skipping score calculation for ${player}: Invalid bid (${playerBid}) or tricks (${playerTricks})`);
           }
       });


        let nextRound = state.currentRound;
        let nextDealerIndex = state.dealerIndex;
        let gameIsOver = false;
        let eliminatedPlayerForThisRound = null;
        let nextEliminatedPlayers = [...state.eliminatedPlayers];
        let nextActivePlayers = [...state.players];

        if (state.currentRound < 14) {
            nextRound++;
            nextDealerIndex = (state.dealerIndex + 1) % activePlayers.length; // Rotate dealer among active players

            // Check for elimination *before* updating Firebase state for the next round
            eliminatedPlayerForThisRound = checkElimination(currentScores, nextActivePlayers, nextRound); // Check based on new scores and *next* round

            if (eliminatedPlayerForThisRound) {
                nextEliminatedPlayers.push(eliminatedPlayerForThisRound);
                nextActivePlayers = nextActivePlayers.filter(p => p !== eliminatedPlayerForThisRound); // Update active players list

                 // Adjust dealer index if the eliminated player affects the rotation
                 // Find the original index of the eliminated player in the *previous* active player list
                 const originalEliminatedIndex = state.players.indexOf(eliminatedPlayerForThisRound);
                 if (originalEliminatedIndex !== -1 && originalEliminatedIndex < nextDealerIndex) {
                    // If someone before the *new* dealer (in the old list) got eliminated, the new dealer's index effectively shifts down by 1 in the *new* list
                    nextDealerIndex--;
                 }
                 // Ensure dealer index wraps correctly within the *new* list of active players
                 nextDealerIndex = nextDealerIndex % Math.max(1, nextActivePlayers.length);
            }

        } else {
            nextRound = 15; // Mark game as ended
            gameIsOver = true;
            saveCompletedGameToLocal(state); // Save final state to local storage history
        }

        // Prepare updates for Firebase
        const updates = {};
        updates['/scores'] = currentScores; // Update all scores
        updates['/currentRound'] = nextRound;
        updates['/bidPhase'] = true; // Reset to bidding phase for next round (or stays true if game over)
        updates['/dealerIndex'] = nextDealerIndex;
        updates['/players'] = nextActivePlayers; // Update active players list if someone was eliminated
        updates['/eliminatedPlayers'] = nextEliminatedPlayers; // Update eliminated list

        // Reset bids and tricks for all potentially active players for the next round
        const resetBids = {};
        const resetTricks = {};
        nextActivePlayers.forEach(p => {
            resetBids[p] = null;
            resetTricks[p] = null;
        });
        updates['/bids'] = resetBids;
        updates['/tricks'] = resetTricks;


        gameRef.update(updates)
         .then(() => {
            console.log(`Round ${state.currentRound} results submitted. Proceeding to round ${nextRound}.`);
            if(gameIsOver) {
                console.log("Game Over!");
                hideEliminationBanner();
            } else {
                checkUpcomingElimination(); // Check needed after state change
            }
            // State update and re-render happens via Firebase listener
         })
         .catch(err => {
            console.error("Failed to submit round results:", err);
            alert("Error submitting round results. Please try again.");
         });
    }

    function saveCompletedGameToLocal(finalState) {
        // Saves to the browser's local storage, not Firebase
        const winners = getWinners(finalState);
        const completedGame = {
            date: new Date().toISOString(),
            winners: winners,
            score: winners.length > 0 ? (finalState.scores[winners[0]] || 0) : 0,
            players: [...finalState.players], // Active players at end
            finalScores: {...finalState.scores},
            eliminatedPlayers: [...finalState.eliminatedPlayers]
        };

        const localCompletedGames = JSON.parse(localStorage.getItem('completedGames')) || [];
        localCompletedGames.push(completedGame);
        localStorage.setItem('completedGames', JSON.stringify(localCompletedGames));

        // Update the side menu immediately
        renderCompletedGames();
    }

    function resetGame() {
        if (!firebaseConnected) { alert("Not connected to the server."); return; }

        if (confirm("Are you sure you want to start a new game? This will clear the current game for EVERYONE connected.")) {
            // Reset the entire game node in Firebase to initial state
            const initialState = {
                players: [],
                gameStarted: false,
                currentRound: 1,
                dealerIndex: 0,
                bids: {},
                tricks: {},
                scores: {},
                bidPhase: true,
                eliminatedPlayers: []
            };
            gameRef.set(initialState)
              .then(() => {
                  console.log("Game reset for everyone.");
                  // Hide elimination banner
                  hideEliminationBanner();
                  previousHtml = ''; // Force re-render from scratch via listener
                  // Listener will update local state and render
              })
              .catch(err => {
                  console.error("Failed to reset game:", err);
                  alert("Error resetting game. Please try again.");
              });
        }
    }

    // --- Helper & Validation Functions ---

    function escapeHtml(unsafe) { /* ... (no changes needed) ... */
        if (unsafe === null || unsafe === undefined) return '';
        return String(unsafe)
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#39;");
    }

    function getDealerName(currentState) {
        if (!currentState.gameStarted || !currentState.players || currentState.players.length === 0) {
            return null;
        }
        const adjustedIndex = Math.max(0, Math.min(currentState.dealerIndex, currentState.players.length - 1));
        return currentState.players[adjustedIndex];
    }

    function getLastPlayerName(currentState) {
        if (!currentState.gameStarted || !currentState.players || currentState.players.length < 2) {
            return null; // Need at least 2 players for a "last player"
        }
        const numPlayers = currentState.players.length;
        const adjustedDealerIndex = Math.max(0, Math.min(currentState.dealerIndex, numPlayers - 1));
        const lastPlayerIndex = (adjustedDealerIndex - 1 + numPlayers) % numPlayers;
        return currentState.players[lastPlayerIndex];
    }

     function isLastPlayer(playerName, currentState) {
        return playerName === getLastPlayerName(currentState);
     }

    function calculateTotalBids(bids) {
        return Object.values(bids || {}).reduce((sum, bid) => sum + (bid || 0), 0);
    }
    function calculateTotalTricks(tricks) {
        return Object.values(tricks || {}).reduce((sum, trick) => sum + (trick || 0), 0);
    }

    function calculatePotentialBidTotal(playerMakingBid, bidValue, currentState) {
        const potentialBids = { ...currentState.bids };
        potentialBids[playerMakingBid] = bidValue ?? 0; // Treat null/undefined as 0 for calculation
        return calculateTotalBids(potentialBids);
    }


     function allPlayersHaveBid(currentState) {
         if (!currentState.players || currentState.players.length === 0) return false;
         return currentState.players.every(player =>
             currentState.bids[player] !== undefined && currentState.bids[player] !== null
         );
     }

     function allPlayersHaveTricks(currentState) {
         if (!currentState.players || currentState.players.length === 0) return false;
         return currentState.players.every(player =>
             currentState.tricks[player] !== undefined && currentState.tricks[player] !== null
         );
     }

    // Checks if all bids are entered AND the total is valid (not equal to round)
    function allBidsEntered(currentState) {
      if (!currentState.gameStarted || !currentState.bidPhase) return false;
      if (!allPlayersHaveBid(currentState)) return false; // Check if everyone has placed *a* bid

      const totalBids = calculateTotalBids(currentState.bids);
      return totalBids !== currentState.currentRound;
    }

    // Checks if all trick inputs are filled
    function allTricksEntered(currentState) {
        if (!currentState.gameStarted || currentState.bidPhase) return false;
        return allPlayersHaveTricks(currentState);
    }

    // Checks if the total tricks match the round number
    function validateTricksTotal(currentState) {
      if (!currentState.gameStarted || currentState.bidPhase) return false;
      const totalTricks = calculateTotalTricks(currentState.tricks);
      return totalTricks === currentState.currentRound;
    }

    function getWinners(currentState) {
      if (!currentState.gameStarted || currentState.currentRound <= 14) return [];
      // Ensure scores object exists and has entries
      if (!currentState.scores || Object.keys(currentState.scores).length === 0) return [];

      // Consider only players who were active at the end or eliminated
      const finalPlayers = [...new Set([...currentState.players, ...currentState.eliminatedPlayers])];
       if (finalPlayers.length === 0) return [];

      let highestScore = -Infinity;
       finalPlayers.forEach(player => {
           const score = currentState.scores[player] || 0;
           if (score > highestScore) {
               highestScore = score;
           }
       });

      // Handle case where no scores > -Infinity (e.g., all players removed?)
      if (highestScore === -Infinity) return [];

      return finalPlayers.filter(player => (currentState.scores[player] || 0) === highestScore);
    }

    function getSortedPlayers(scores, playerList) {
        // Sorts a given list of players based on the scores object
        return playerList
            .map(player => ({ name: player, score: scores[player] || 0 }))
            .sort((a, b) => b.score - a.score)
            .map(p => p.name);
    }


    // --- Elimination Banner Logic ---
    function checkUpcomingElimination() {
      if (!state.gameStarted || state.currentRound > 14 || !state.players || state.players.length < 2) {
        hideEliminationBanner();
        return;
      }

      const threshold = 56;
      for (let futureRound = state.currentRound; futureRound <= 14; futureRound++) {
        const product = state.players.length * futureRound;
        if (product > threshold) {
          showEliminationBanner(futureRound);
          return;
        }
      }
      hideEliminationBanner();
    }

    function showEliminationBanner(round) {
        // Show the *inline* banner only
      const roundMessage = document.getElementById('round-elimination-message');
      const roundBanner = document.getElementById('round-elimination-banner');

      if (roundMessage && roundBanner) {
        roundMessage.textContent = `Elimination at Round ${round}`;
        roundBanner.style.display = 'flex';
      }
       // Keep the fixed banner hidden
      const origBanner = document.getElementById('elimination-banner');
      if (origBanner) origBanner.style.display = 'none';
    }

    function hideEliminationBanner() {
      const origBanner = document.getElementById('elimination-banner');
      if (origBanner) origBanner.style.display = 'none';
      const roundBanner = document.getElementById('round-elimination-banner');
      if (roundBanner) roundBanner.style.display = 'none';
    }

    // --- Game Details Modal ---
    function showGameDetails(gameIndex) {
        // Uses local storage data
      const game = state.completedGames[gameIndex];
      if (!game) return;

      const gameDate = new Date(game.date);
      const formattedDate = `${gameDate.toLocaleDateString()} ${gameDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;

      game.eliminatedPlayers = game.eliminatedPlayers || []; // Ensure array exists

      const allParticipants = [...new Set([...(game.players || []), ...game.eliminatedPlayers])];
      const sortedPlayers = getSortedPlayers(game.finalScores || {}, allParticipants); // Use helper


      let content = `
        <div class="game-date"><i class="fas fa-calendar-alt"></i> ${formattedDate}</div>

        <div class="game-details-winners">
          <h4>${game.winners.length === 1 ? 'Winner' : 'Winners (Tie)'}</h4>
          <div class="winner-names">
            <i class="fas fa-crown"></i> ${game.winners.map(escapeHtml).join(' & ')}
            <span style="margin-left:auto;">${game.score} points</span>
          </div>
        </div>

        <h4>All Players (${allParticipants.length})</h4>
        <div class="player-scores-container">
          <div class="player-scores-header">
            <span>Player</span>
            <span>Final Score</span>
          </div>
          <div class="player-scores-list">
      `;

      sortedPlayers.forEach((player, index) => {
        const isWinner = game.winners.includes(player);
        const isEliminated = game.eliminatedPlayers.includes(player);
        const playerScore = game.finalScores[player] || 0;

        content += `
          <div class="player-score-item ${isWinner ? 'winner' : ''} ${isEliminated ? 'eliminated' : ''}">
            <span class="player-score-name">${index + 1}. ${escapeHtml(player)} ${isEliminated ? '<i class="fas fa-user-slash" title="Eliminated"></i>' : ''}</span>
            <span class="player-score-value">${playerScore}</span>
          </div>
        `;
      });

      content += `
          </div>
        </div>
      `;

      gameDetailsBody.innerHTML = content;
      gameDetailsModal.classList.add('active');
    }

  </script>

  <!-- Service Worker Registration (No changes needed) -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(registration => {
            console.log('Service Worker registered successfully:', registration.scope);
          })
          .catch(error => {
            console.error('Service Worker registration failed:', error);
          });
      });

      // Listen for service worker updates
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        console.log('Service Worker updated, potentially refresh needed.');
        // Optionally prompt user to refresh
      });

      // Handle installation prompt (Add to Home Screen)
      let deferredPrompt;
      const addToHomeEl = document.createElement('div');
      addToHomeEl.style.display = 'none'; // Initially hidden

      window.addEventListener('beforeinstallprompt', (e) => {
        console.log('beforeinstallprompt event fired');
        // Prevent Chrome 67 and earlier from automatically showing the prompt
        e.preventDefault();
        // Stash the event so it can be triggered later
        deferredPrompt = e;

         // Only show banner if not already installed
         if (!window.matchMedia('(display-mode: standalone)').matches && !navigator.standalone) {
            // Create installation notification
            addToHomeEl.style.display = 'flex';
            addToHomeEl.className = 'elimination-banner'; // Reuse style
            addToHomeEl.style.position = 'fixed';
            addToHomeEl.style.bottom = '1rem'; // Position at bottom
            addToHomeEl.style.top = 'auto';
            addToHomeEl.style.left = '50%';
            addToHomeEl.style.transform = 'translateX(-50%)';
            addToHomeEl.style.zIndex = '850';
            addToHomeEl.innerHTML = `
            <i class="fas fa-download"></i>
            <span>Install 14-High! App</span>
            `;

            // Add install button
            const installBtn = document.createElement('button');
            installBtn.style.marginLeft = '8px';
            installBtn.style.padding = '2px 8px';
            installBtn.style.border = 'none';
            installBtn.style.background = 'white';
            installBtn.style.color = 'var(--primary)'; // Use CSS var
            installBtn.style.borderRadius = '3px';
            installBtn.style.fontSize = '0.75rem';
            installBtn.style.fontWeight = 'bold';
            installBtn.style.cursor = 'pointer';
            installBtn.innerText = 'Install';

            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.style.marginLeft = '8px';
            closeBtn.style.padding = '0px 6px';
            closeBtn.style.border = 'none';
            closeBtn.style.background = 'rgba(255,255,255,0.2)';
            closeBtn.style.color = 'white';
            closeBtn.style.borderRadius = '50%';
            closeBtn.style.fontSize = '0.75rem';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.style.cursor = 'pointer';
            closeBtn.innerHTML = '&times;';

            addToHomeEl.appendChild(installBtn);
            addToHomeEl.appendChild(closeBtn);
            document.body.appendChild(addToHomeEl);

            installBtn.addEventListener('click', (e) => {
            // Hide the prompt
            addToHomeEl.style.display = 'none';
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                console.log('User accepted the A2HS prompt');
                } else {
                console.log('User dismissed the A2HS prompt');
                }
                deferredPrompt = null;
            });
            });

            closeBtn.addEventListener('click', () => {
                addToHomeEl.style.display = 'none';
            });
         }

      });

      // Listen for successful installation
      window.addEventListener('appinstalled', (evt) => {
        console.log('Application installed successfully!');
        // Hide the install banner if it's visible
        if (addToHomeEl) {
          addToHomeEl.style.display = 'none';
        }
        deferredPrompt = null;
      });
    }
  </script>
</body>
</html>